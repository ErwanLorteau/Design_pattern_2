:icons: font
:experimental:
= Refactoring to Patterns

- IntelliJ
- Never break the build

== Code Simplification

=== Introduce Compose Method

The "Compose
Method"footnote:[http://c2.com/ppr/wiki/WikiPagesAboutRefactoring/ComposedMethod.html]
pattern is about producing methods that efficiently communicate what
they do and how they do what they do. According to Kent Beck:

[cite, Kent Beck]
____
«Divide your program into methods that perform one identifiable task.
Keep all of the operations in a method at the same level of abstraction.
This will naturally result in programs with many small methods, each a
few lines long.»
____

A Composed Method consists of calls to well-named methods that are all
at the same level of detail. 
Follow the instructions below to simplify
the method `add()` from class `ArrayList`:


.The ArrayList Class
[source,java]
----
include::src/main/java/fr/rtp/util/ArrayList.java[]
----

The `ArrayList` class is composed of three parts:

<1> The _read only_ check part
<2> The grow part
<3> The actual add behavior part

==== Guard Clauses

[sidebar]
.To-Do
--
Invert the "readonly"  check to introduce a "Guard Clause".

[quote]
____
A guard clause is simply a check (the inverted `if`) that immediately exits the function, either with a `return` statement or an exception. Using guard clauses, the possible error cases are identified and there is the respective handling by returning or throwing an adequate exception.
____

TIP: For more information about Guard Clauses, read the refactoring https://refactoring.guru/fr/replace-nested-conditional-with-guard-clauses[Replace Nested Conditinal with Guard Clauses].
--

==== Extract Private Method

[sidebar]
.To-Do
--
Apply the _Extract Method_ refactoring operation to replace the two lines (18-19) that actually adds an element and create the private method `void addElement(Object obj)`.

TIP: To use the _Extract Method_ refactoring, first select le lines you want to place in a different method, then go to menu:Refactor[Extract/Introduce > Method...] and name the new method.
--

==== Replace Magic Numbers
.To-Do
[sidebar]
--
Apply the _Extract Constant_ refactoring operation to replace the magic number `10` and introduce an "Explanatory Variable" named `GROWTH_INCREMENT`.

[quote, Kent Beck]
____
Explanatory variables are variables with meaningful names, which held intermediate values of complex calculations to break them up.

The simple use of explanatory variables makes it clear that the first matched group is the key, and the second matched group is the value.
____

TIP: To use the _Extract Constant_ refactoring operation, first select the value (10), then go to menu:Refactor[Extract/Introduce > Constant...] and name the new constant.
--

==== Extract Private Method Again

[sidebar]
.To-Do
--
Apply the _Inline variable_ refactoring operation to `newSize` and then apply the _Extract
Method_ refactoring operation  to the code that checks whether the `element`  array is at its capacity and needs to grow, and create the method `atCapacity()`.

In other words, replace the boolean expression of the `if` statement by the call of `atCapacity()`.

TIP: To inline a variable, select its usage (not its definition) and go to menu:Refactor[Inline Variable]

--

==== Extract the `grow()` Method

[sidebar]
.To-Do
--
Finally, apply the __Extract Method__ operation to the part of the code that grows the size of the array, creating the `grow()` private method.
--

==== Final code

After applying all the previous refactoring operations, your code should look like:

[source,java]
----
public void add(Object child) {
    if (readOnly) {
        return;
    }
    if (atCapacity()) {
        grow();
    }
    addElement(child);
}
----

=== Replace Conditional Logic with Strategy

The https://naomod.univ-nantes.io/patterns/strategy.html[Strategy Design Pattern] defines a family of algorithms, encapsulates each algorithm, and make them interchangeable, letting the algorithm vary independently of the clients that use it.

We can apply this pattern to classes where several methods have similar structure: a sequence of similar conditions.

For instance, let us consider the `Loan`
classfootnote:[http://www.informit.com/articles/article.aspx?p=1398607&seqNum=2],
from Joshua Kerievsky’s book <<rtp>>:

[source,java]
----
include::src/main/java/fr/rtp/loan/Loan.java[]
----

This class deals with calculating capital for three different kinds of bank loans:

Term loan::
A loan from a bank for a specific amount that has a specified repayment schedule and a fixed or floating interest rate.
Revolver::
A credit that is automatically renewed as debts are paid off.
Advised line::
A credit that a financial institution approves and maintains for a customer.

Much of the logic of methods and deals with figuring out whether the loan is a term loan, a revolver, or an advised line.

For example, a `null` expiry date and a non-`null` maturity date indicate a term loan.
A `null` maturity and a non-`null` expiry date indicate a revolver loan.

In this exercise, we will use the Strategy Design Pattern to simplify the calculation of the loan’s capital.

==== Create the `CapitalStrategy` class

[sidebar]
.To-Do
--
. Create an empty class named `CapitalStrategy`.
. Add a field named `strategy` to class `Loan`.

[source, java]
.The empty `CapitalStrategy`class and its usage
----
public class CapitalStrategy {}
public class Loan {
    private CapitalStrategy strategy = new CapitalStrategy();
    // (...)
}
----
--

==== Move Field `commitment` to `CapitalStrategy`

.To-Do
****
[NOTE]
--
We need to move the methods `capital()` and `duration()` from class `Loan` to class `CapitalStrategy`.

To this end, we will need first to move first the fields and auxiliary methods used by these two methods.
--

. Select the `commitment` field at its declaration and go to menu:Refactor[Encapsulate Fields...].
.. *Do not* encapsulate the _Set access_  (the field is never modified)
.. Set the _Accessor Visibility_ to `private`.
. icon:hand[] Move the `commitment` field to class `CapitalStrategy`:
.. Cut&Paste the field declaration to move it. Make it `final`.
.. Create a new constructor in class `CapitalStrategy` that initializes field `commitment`. Use menu:Code[New... > Constructor].
.. Move the initialization of field `strategy`, from its declaration to the two constructors. At the same time, remove the initializations of field `commitment`, which no longuer exists.
.. Copy&Paste the accessor method (`getCommitment()`).
.. Change the visibility of the pasted method to `protected`.
.. Make the original method _delegate_ its behavior to the new one.
.. Run all tests and check that the code works and before the changes.

.CapitalStrategy class, after changes
[source,java]
----
public class CapitalStrategy {
    private final double commitment;

    public CapitalStrategy(double commitment) {
        this.commitment = commitment;
    }

    protected double getCommitment() {
        return commitment;
    }
}
----

.Snippet of class Loan, after changes
[source,java]
----
public class Loan {
    private CapitalStrategy strategy;
    public Loan(double commitment, double outstanding, Date start, Date expiry, Date maturity, int riskRating) {
        strategy = new CapitalStrategy(commitment);
        // (...)
    }
    public Loan(double commitment, Date start, Date maturity, int riskRating) {
        strategy = new CapitalStrategy(commitment);
        // (...)
    }
    // (...)
    private double getCommitment() {
        return strategy.getCommitment();
    }
}
----
****

==== Move fields  maturity, expirity, outstanding, riskRating and start to CapitalStrategy

.To-Do
****
. Encapsulate fields `maturity`, `expirity`, `outstanding`, `riskRating` and `start` with a private *get* accessor.

. Cut&Paste the field declarations to move them. Make them `final`.

. Create a new constructor in class `CapitalStrategy` that initializes field `commitment`.
+
[TIP]
====
Delete the old constructor and use menu:Code[New... > Constructor] to create a new one.
====
+
. Move the new  accessor methods to `CapitalStrategy`.

. Change the visibility of the pasted method to `protected`.

. Make the original methods _delegate_ their behavior to the new ones.

. Run all tests and check that the code works and before the changes.

.CapitalStrategy class after changes
[source,java]
----
public class CapitalStrategy {
    private final double commitment;
    private final double outstanding;
    private final Date maturity;
    private final Date expiry;
    private final Date start;
    private final int riskRating;

    public CapitalStrategy(double commitment, double outstanding, Date maturity, Date expiry,
                           Date start, int riskRating) {
        this.commitment = commitment;
        this.outstanding = outstanding;
        this.maturity = maturity;
        this.expiry = expiry;
        this.start = start;
        this.riskRating = riskRating;
    }

    protected double getCommitment() {
        return commitment;
    }

    protected double getOutstanding() {
        return outstanding;
    }

    protected Date getMaturity() {
        return maturity;
    }

    protected Date getExpiry() {
        return expiry;
    }

    protected Date getStart() {
        return start;
    }

    protected int getRiskRating() {
        return riskRating;
    }
}
----

.Snippet of class Loan, after changes
[source,java]
----
public class Loan {
    public Loan(double commitment, double outstanding, Date start, Date expiry, Date maturity, int riskRating) {
        strategy = new CapitalStrategy(commitment, outstanding, maturity, expiry, start, riskRating);
        payments = new HashSet<Payment>();
    }

    public Loan(double commitment, Date start, Date maturity, int riskRating) {
        strategy = new CapitalStrategy(commitment, commitment, maturity, null, start, riskRating);
        payments = new HashSet<Payment>();
    }
// (...)
    private double getOutstanding() {
        return strategy.getOutstanding();
    }

    private Date getMaturity() {
        return strategy.getMaturity();
    }

    private Date getExpiry() {
        return strategy.getExpiry();
    }

    private Date getStart() {
        return strategy.getStart();
    }

    public int getRiskRating() {
        return strategy.getRiskRating();
    }
}
----
****

==== Move method yearsTo() to CapitalStrategy

.To-Do
****
. icon:hand[] Move, using Cut&Paste, fields `today`, `MILLIS_PER_DAY` and `DAYS_PER_YEAR` to class CapitalStrategy
. icon:hand[]  Copy, using Copy&Paste, method `yearsTo()` to class `CapitalStrategy`.
.. Change the visibility of the new method to `protected`.
. Replace the body of the original method with a delegation to the new method.
. Run all tests and check that the code works and before the changes.

.Method Loan::yearsTo() after changes
[source,java]
----
private double yearsTo(Date endDate) {
    return strategy.yearsTo(endDate);
}
----

.Method CapitalStrategy::yearsTo() after changes
[source, java]
----
protected double yearsTo(Date endDate) {
    Date beginDate = (today == null ? getStart() : today);
    return ((endDate.getTime() - beginDate.getTime()) / MILLIS_PER_DAY) / DAYS_PER_YEAR;
}
----
****

==== Move method duration() to CapitalStrategy

.To-Do
****
NOTE: Here we will use a different approach to move a method from one class to another, without using Copy&Paste

. Change the visibility of method `weightedAverageDuration()` to `protected`.

. Select all the lines of the body of method `duration()`.

. Go to menu:Refactor[Extract/Introduce > Method...] and extract the new method.
.. Use a temporary name for the method, `extracted()` is just fine.

. Go to menu:Refactor[Move Instance Method] to move the new method to class `CapitalStrategy`.
.. Do not worry about the visibility warnings.

. icon:hand[] Replace `loan` by `this` in the new method, when the method already exists in class `CapitalStrategy`
+
|===
|Replace | by

| `loan.getExpiry()`
| `this.getExpiry()`

| `loan.getMaturity()`
| `this.getMaturity()`

| `loan.yearsTo(loan.getExpiry())`
| `this.yearsTo(this.getExpiry())`
|===

. Select the new method name, go to menu:Refactor[Rename...] and rename it to `duration()`.

. Run all tests and check that the code works and before the changes.

.Method `Loan::duration()` after changes
[source,java]
----
----
****

==== Move method capital() to CapitalStrategy

.To-Do
****
. Move method `outstandingRiskAmount()`
.. This method has two method calls: `getCommitment()` and `getOutstanding()`.
.. Inline these calls:
... Click on the first method call then go to menu:Refactor[Inline Method...]
... Choose "Inline this only and keep the method"
... Do the same with the second method call.
+
.Method `outstandingRiskAmount()` after inlines
[source,java]
----
private double unusedRiskAmount() {
    return (strategy.getCommitment() - strategy.getOutstanding());
}
----
.. Click on the name of method `outstandingRiskAmount()`.
.. Go to menu:Refactor[Move Instance Method...] and move method to class `CapitalStrategy`.
.. Choose visibility "Escalate" and let IntelliJ choose the appropriate visibility.

. Move method `outstandingRiskAmount()`
.. Inline the only method call
.. Move method to class `CapitalStrategy`.

. Move method `riskFactor()`
.. Inline the method call `getRiskRating()`
.. Move method to class `CapitalStrategy`.

. Move method `unusedRiskFactor()`
.. Inline the method call `getRiskRating()`
.. Move method to class `CapitalStrategy`.

. Move method  `getUnusedPercentage()`
.. Go to menu:Refactor[Move Instance Method...] and move method to `Capital Strategy`

. Finally, move method `capital()`
.. Inline all method calls
+
.Method capital() after inlines and before move
[source, java]
----
public double capital() {
    if (strategy.getExpiry() == null && strategy.getMaturity() != null) // Term Loan
        return strategy.getCommitment() * strategy.duration(this) * strategy.riskFactor();
    if (strategy.getExpiry() != null && strategy.getMaturity() == null) {
        if (strategy.getUnusedPercentage() != 1.0) // Revolver
            return strategy.getCommitment() * strategy.getUnusedPercentage() * strategy.duration(this) * strategy.riskFactor();
        else // Advised Line
return (strategy.outstandingRiskAmount() * strategy.duration(this) * strategy.riskFactor())
+ (this.strategy.unusedRiskAmount() * strategy.duration(this) * strategy.unusedRiskFactor());
    }
    return 0.0;
}
----

.. Select the method body (all method code lines) and go to menu:Refactor[Extract/Introduce > Method]
... Choose a temporary name for the method, for instance `extractedCapital()`
.. Click on the name of the new method and go to menu:Refactor[Move Instance Method...] and move it to class `CapitalStrategy`
.. Rename the new method to `capital()`

. In the end, you should have the following code:
+
.Method Loan::capital() after changes
[source,java]
----
public double capital() {
    return strategy.capital(this);
}
----
+
.Method CapitalStrategy::capital() after changes
[source,java]
----
double capital(Loan loan) {
    if (getExpiry() == null && getMaturity() != null) // Term Loan
        return getCommitment() * duration(loan) * riskFactor();
    if (getExpiry() != null && getMaturity() == null) {
        if (getUnusedPercentage() != 1.0) // Revolver
            return getCommitment() * getUnusedPercentage() * duration(loan) * riskFactor();
        else // Advised Line
            return (outstandingRiskAmount() * duration(loan) * riskFactor())
                    + (unusedRiskAmount() * duration(loan) * unusedRiskFactor());
    }
    return 0.0;
}
----
. Run all tests and check that the code works and before the changes.
****

==== Replace Conditional with Polymorphism

Now that we migrated methods `capital()` and `duration()` to `CapitalStrategy`, we will create the classes that play the _Concrete Strategy_ roles and move that methods to these classes.

.To-Do
****
. Create the _Concrete Strategy_ classes
.. Create the classes `RevolverStrategy`, `TermLoanStrategy`, and `AdvisedLineStrategy`.
.. Make them subclasses of `CapitalStrategy`.
.. Go to menu:Code[Generate... > Constructor] to add a constructor to these classes.

. Instantiate the correct strategy for a Loan.
.. Modify the constructors of class `Loan` and make them instantiate the correct strategy.
+
[NOTE]
====
According to the code:

* When `expiry` is `null`, the strategy should be "Term Loan".
* When `expiry` is not `null` and `maturity` is `null`, the strategy should be "Revolver".
* Otherwise, the strategy should be "Advised Line".
====

. Make classe `CapitalStrategy` abstract.
. Push down method `capital()`
.. Click on the method name, then go to menu:Refactor[Push Members Down...]
.. Add an abstract method `capital()` to class `CapitalStrategy`.

. Open class `RevolverStrategy` and remove the parts of code that do not concern a revolver loan
+
.Method RevolverStrategy::capital() after changes
[source,java]
----
double capital(Loan loan) {
    return getCommitment() * getUnusedPercentage() * duration(loan) * riskFactor();
}
----

. Open class `TermLoanStrategy` and remove the parts of code that do not concern a revolver loan
+
.Method TermLoanStrategy::capital() after changes
[source,java]
----
double capital(Loan loan) {
    return getCommitment() * duration(loan) * riskFactor();
}
----

. Open class `AdvisedLineStrategy` and remove the parts of code that do not concern a revolver loan
+
.Method AdvisedLineStrategy::capital() after changes
[source,java]
----
double capital(Loan loan) {
    return (outstandingRiskAmount() * duration(loan) * riskFactor())
+ (unusedRiskAmount() * duration(loan) * unusedRiskFactor());
}
----

. Repeat the same operations for method `CapitalStrategy::duration()`

. Run all tests and check that the code works and before the changes.
****

=== Chain Constructors

Classes may have several constructors: this is normal, as there may be
different ways to instantiate objects of a same class.
However, maintenance problems arise when code snippets are duplicated across the code source.

Consider the three constructors of class `BankLoan` presented in listing <<lst:bankloan>>, which have duplicated code.
We will use the refactoring operation named _Chain Constructors_,
whose goal is to remove duplication in constructors by making them call each other.

First, we analyze these constructors to find out which one is the *catch-all constructor*,
the one that handles all the construction details.
It seems that it should be constructor 3,
since making constructors 1 and 2 call 3 can be achieved with a minimum amount of work.

.Class BankLoan
[source#lst:bankloan,java]
----
include::src/main/java/fr/rtp/utilities/chainconstructors/BankLoan.java[]
----

.To-Do
****
. Change constructor 1 to make it call constructor 3.
. Change constructor 2 to make it also call constructor 3.

.BankLoan class after changes
[source,java]
----
public class BankLoan {
    // (...)
    public BankLoan(float national, float outstanding, int rating, Date expiry) {
        this(new TermROC(), national, outstanding, rating, expiry, null);
    }

    public BankLoan(float national, float outstanding, int rating, Date expiry, Date maturity) {
        this(new RevolvingTermROC(), national, outstanding, rating, expiry, maturity);
    }

    public BankLoan(BankCapitalStrategy strategy, float national, float outstanding, int rating, Date expiry, Date maturity) {
        this.strategy = strategy;
        this.national = national;
        this.outstanding = outstanding;
        this.rating = rating;
        this.expiry = expiry;
        this.maturity = maturity;
    }
}
----
****

=== Replace Constructors with Creation Methods

The goal of the _Replace Constructors with Creation Methods_ refactoring operation is to replace constructors with intention-revealing creation methods that return object instances.

[IMPORTANT]
====
_Creation Method_ is a generic term to designate any method that creates instances of a class.
For instance, the https://refactoring.guru/design-patterns/factory-method[Factory Method] and
the https://refactoring.guru/design-patterns/builder[Builder] Design Patterns use _Creation Methods_.
====

Creation methods have at least two advantages, that cannot be achieved in Java.
First, they can have different names and thus communicate intention efficiently.
Second, different creation methods can have the same number of parameters.

We will apply this refactoring to improve the constructions of class `Loan`.
Consider the source code of this class, presented below.

[source,java]
----
include::src/main/java/fr/rtp/creation/creationmethods/Loan.java[]
----

.To-Do
****
. To apply this refactoring, we need to find a code that calls one of these constructors. For instance, in a test case, such as link:./src/test/java/fr/rtp/creation/creationmethods/CapitalCalculationTest.java[CapitalCalculationTest]

. Create Creation Method
.. Select the code that creates an instance of `Loan`, i.e. `new Loan(commitment,
riskRating, maturity)`
.. Go to menu:Refactor[Extract/Introduce > Method...]. Name the method `createTermLoan()`

. Make it static and public
.. Click on the method name
.. Go to menu:Refactor[Make static...]
.. Make it public
+
.Creation Method createTermLoan()
[source,java]
----
public static Loan createTermLoan(Date maturity, int riskRating, double commitment) {
    return new Loan(commitment, riskRating, maturity);
}
----

. Move method to class `Loan`
.. Click on the method name and go to menu:Refactor[Move Members...]
.. Write down the destination (to) class: `fr.rtp.creation.creationmethods.Loan`.

. After doing that, we will need to find all callers of the constructor and update them to call `createTermLoan()`.
.. Click on the first constructor and then go to menu:Navigate[Declaration or Usages].
.. You you find any usage other than the creation method, make it call `createTermLoan()`.


. Inline method
.. Since now the method is now the only caller on the constructor, we can apply the _Inline Method_ refactoring to this
constructor.
.. Inside the creation method, click on the construction call and then go to menu:Refactor[Inline Method..] choose *Inline all and remove the method*.

. Repeat the same procedure to the other constructors, to create
additional creation methods on class `Loan`.
+
.New Creation Methods
[source,java]
----
public static Loan newRevolver(double commitment, Date start, Date expiry, int riskRating) {
    return new Loan(commitment, 0, start, expiry, null, riskRating, new CapitalStrategyRevolver());
}

public static Loan newAdvisedLine(double commitment, Date start, Date expiry, int riskRating) {
    if (riskRating > 3) return null;
    Loan advisedLine = new Loan(commitment, 0, start, expiry, null, riskRating, new CapitalStrategyAdvisedLine()); advisedLine.setUnusedPercentage(0.1);
    return advisedLine;
}
----

. Last step, since the constructors are only used by creation methods, they can become private.
****

=== Replace State-Altering Conditionals with State

[source,java]
----
----

The context class is a class that contains the original state field, a
field that gets assigned to or compared against a family of constants
during state transitions. Apply _Replace Type Code with Class_ on the
original state field such that its type becomes a class. We’ll call that
new class the state superclass.

The context class is known as State: Context and the state superclass as
State: State in Design Patterns.

Class has a field called , which is of type String. The first step is to
change state’s type to be a class by applying the refactoring Replace
Type Code with Class. This yields the following new class:”

....
public class PermissionState {
    private String name;
    private PermissionState(String name) {
        this.name = name;
    }

    public final static PermissionState REQUESTED = new PermissionState("REQUESTED");
    public final static PermissionState CLAIMED = new PermissionState("CLAIMED");
    public final static PermissionState GRANTED = new PermissionState("GRANTED");
    public final static PermissionState DENIED = new PermissionState("DENIED");
    public final static PermissionState UNIX_REQUESTED = new PermissionState("UNIX_REQUESTED");
    public final static PermissionState UNIX_CLAIMED = new PermissionState("UNIX_CLAIMED");

    public String toString() {
        return name;
    }
}
....

image:TypeCodeWithClass.jpg[image]

Each constant in the state superclass now refers to an instance of the
state superclass. Apply Extract Subclass to produce one subclass (known
as State: ConcreteState) per constant, then update the constants in the
state superclass so that each refers to the correct subclass instance of
the state superclass. Finally, declare the state superclass to be
abstract.

PermissionState now contains six constants, all of which are instances
of PermissionState. To make each of these constants an instance of a
subclass of PermissionState, I apply Extract Subclass [F] six times to
produce the result shown in the following diagram. ``Because no client
will ever need to instantiate PermissionState, I declare it to be
abstract:''

....
public abstract class PermissionState...
....

image:extract-subclass.pdf[image]

Find a context class method that changes the value of the original state
field based on state transition logic. Copy this method to the state
superclass, making the simplest changes possible to make the new method
work. (A common, simple change is to pass the context class to the
method in order to have code call methods on the context class.).
Finally, replace the body of the context class method with a delegation
call to the new method.

Repeat this step for every context class method that changes the value
of the original state field based on state transition logic.

Next, I find a method on SystemPermission that changes the value of
permission based on state transition logic. There are three such methods
in SystemPermission: claimedBy(), deniedBy(), and grantedBy(). I start
by working with claimedBy(). I must copy this method to PermissionState,
making enough changes to get it to compile and then replacing the body
of the original claimedBy() method with a call to the new
PermissionState version:

Choose a state that the context class can enter, and identify which
state superclass methods make this state transition to other states.
Copy the identified method(s), if any, to the subclass associated with
the chosen state and remove all unrelated logic.

Unrelated logic usually includes verifications of a current state or
logic that transitions to unrelated states.

Repeat for all states the context class can enter.

“In PermissionState, I can now delete the bodies of claimedBy(),
deniedBy(), and grantedBy(), leaving the following:

abstract class PermissionState public String toString(); public void
claimedBy(SystemAdmin admin, SystemPermission permission) public void
deniedBy(SystemAdmin admin, SystemPermission permission) public void
grantedBy(SystemAdmin admin, SystemPermission permission)

Delete the bodies of each of the methods copied to the state superclass
during step 3 to produce an empty implementation for each method.

[bibliography]
== References

* [[[rtp, 1]]] Andy Hunt & Dave Thomas. The Pragmatic Programmer:
From Journeyman to Master. Addison-Wesley. 1999.
